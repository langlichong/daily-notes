

数据库事务都可以抽象成一个查询加更新过程（插入= 先查询+后写入 ，删除= 先查询后删除）

事务的本质就是在做查询的时候先上锁，把系统的某一部分数据独占起来，不让其他线程看到，既看不到也不能写入。

但是如上的枷锁机制还可以优化，这就是事务的四种不同级别的隔离措施，其实是为了解决上述加锁模式产生的性能问题。

人脑思考是顺序的，利于人脑理解的模型其实其性能就比较差，反之，越复杂的模型，性能越高的模型人脑却难以清楚地理解。

事务单元之间也是有先后关系的。

NOSQL 说白了就是map套map，第一个map说明数据在哪一台服务器上，第二个map则说明这个数据具体是什么。

事务本质：锁与并发 ，其最主要劣势就是性能。

事务目的：保证数据的一致性（ACID）。

----------------------
two phase locking 与 two phase commit
-----------------------------------------

常见的事务单元：
	建立索引、读取一行记录、写入一行记录并同时更新改行记录的所有索引、删除整张表、

事务单元与事务单元之间关系
 事务单元间关系——happen-before：读写、写读、读读、写写
	：A转账给B时候来了个C转账给A 

如何让事务单元快速进行或者完成？（最基本的事务单元是顺序进行——性能问题（不断追求性能不断改变））
	1、排队：事务进行排队，顺序进行处理（所有事务单元排在同一个队列）（其实就是ACID中的A——读写完全串行）
	2、排它锁：将事务单元排在多个队列上（其实就是通过加锁方式来控制并发）
	3、读写分离 —— 读写锁（其实是针对读读进行的优化）
	4、MVCC（多版本并发控制）：目前主流数据库实现，能做到写不阻塞读，针对写读的优化。
    ——本质就是 copy on write（每次都在新的地方写并不是在原位置写） 。
							 : 此种方式使得 读读、读写、写读之间没有任何冲突，唯一需要处理的就是写写。
	
		可重复读（加了读锁）：在第一次读完之后，在锁没有释放的前提下再去读的时候读到的结果是一样的。
		如果将读锁完全去掉？：进一步提升并行度，问题是发生不可重复读（其实ACID的I就是对一致性的破坏）
 
 有了一致性为什么还要隔离性？？？？矛盾？？？
******** 传统来说，最强的一致性就是读写完全串行化，但性能有问题，于是出现排它锁来优化（通过设立多个不同隔离级别来分批的打碎传统的一致性）。*******
    事务的隔离级别其实就是为了优化事务所引起的性能问题——并发度问题。

为了提升性能：降低锁的颗粒度（哪里该加锁哪里不应该），而这种措施又会增加使用或者说编程的复杂度。

两阶段事务： two phase lock ,即加锁阶段与解锁阶段，而且二者不可以交叉（）

事务问题处理：
	1、mvcc下：一个读请求应该读哪一个写请求之后的数据？即谁先谁后？
	   （Oracle中就是SCN，Mysql-Innodb中是Trx_id）—— 维持一个自增号，每次都会加一（即可以读到最新的数据值）——本质就是时间戳
	
	时间戳分类：
		逻辑时间戳：只需保证先后顺序，并非真正意义上的时间的描述。
		物理时间戳：真正的时间描述
		
	2、事务故障恢复	
		可能的情况：
			业务属性不匹配：比如转账时候，发现账户余额不足
			系统崩溃：如转账操作进行到——A账户余额减少，此时系统crash。
			经常会看到在数据库系统重启时候会有一个状态：recovery，此时系统是不对外暴露监听的，外部就不会看到不一致的数据状态。
	3、死锁与死锁检测
		死锁条件：两个线程、不同方向、相同资源
		解决：
			a、尽可能不出现死锁——降低隔离级别（如尽量不加读锁等）
			b、碰撞检测（效率较高 - 主流数据库方式）
			c、等锁超时
-----------------	以上属于单机下事务情况---------------------
 
----分布式事务

深入单机事务：
	事务的ACID：其中I（隔离性）中又分了很多（如换读、不可重复读等）
	单机事务典型异常处理策略
	事务调优的原则
	
 原子性：要么全部成功，要么全部失败。****为了保证原子性需要记录回滚段即记录undo日志（应该只对写操作记录）****
	Bob转100给Smith（MVCC下）
	version1： Bob有100，Smith有0元。
	version2： Bob有0元，Smith有0元.
		（undo：Bob有100元，Smith有0元）--回滚段
	version3： Bob有0元，Smith有100元。（可能commit失败）
	     （undo：Bob有0元，Smith有0元）
 一致性：Can（happen-before） 
		其实是为了解决在只有原子性情况下，事务单元之间并发时候出现的问题（如上述进行到版本version2时候另一个事务进入后引发数据问题）
        保证：保证能看到系统内所有更改，即保证一个事务单元全部完成后才可以被另一个事务单元看见（这就是强一致性）
				（但这种保证会导致并发上不去，性能有问题，这就引发优化——隔离性）。
				
 隔离性：以性能为理由对一致性的破坏。
	序列化读写：即用排它锁将该事务单元锁住。 —— 性能非常差（性能差意味着不可用）	
	读写锁：分如下两个隔离级别
		可重复读：可做到读读并行
		读已提交：读锁可以被写锁升级（做到读写并行：可能发生不可重复读 —— 同一事务两次读到结果不一样）
	    读未提交：只加写锁，读不加锁，此时可以做到读读、读写、写读都可并行。（可能读到写过程中的数据）
		
	******其实在具体实现四种标准隔离级别时候，还有一种扩展实现即snapshot（快照即MVCC），而该种实现方式无法归类到已经提出的隔离级别中****
	mvcc核心思想：copy on write 加 无锁编程。
	              读的时候可以在写的回滚段所在的版本中进行读操作，相当于读写事务进行前的快照版本。
	为了归类目前将mvcc快照读映射到读未提交与读已提交。
 持久性：一旦事务提交了就要保证数据不丢。但如何保证数据不丢失？？？？
		：RAID 
*****事物的定义滞后于事物的发展**********
ACID只是SQL92的一种标准，但不一定是对的。

？？？？？？写写有没有可能并行呢？？？？？？？？？？

提交系统吞吐：
	1、提交到内存后立即返回，不立即落地磁盘
	2、Group Commit ：将内存数据打包到磁盘
事务调优：
		1、尽可能降低锁的覆盖范围：如 表级别锁 -》行级别锁 ；原位锁（mvcc）
		2、增加锁上可并行的线程数：读写锁分离
		3、选择正确的锁类型（悲观锁（让线程blocking）、乐观锁，数据争抢严重就选择悲观锁）
		
-----------------分布式事务--------------------
共享数据：不能被同时修改。
事务本质就是保证在对共享数据修改时时顺序进行的。
通过消息传递方式解决问题。
